# 客户端

消息类型
1. h5到容器的消息 - 类似无返回值的函数调用
比如console.log这种，h5不需要容器侧的回调
- 命名：每个单独命名，\`handleH5${apiEnum}\`
- 每个单独注册，apiEnum为字符串类型
- 没有返回值，也不会抛出异常，如果出现异常，调用handleContainerEvent处理
2. 容器到h5的消息 - 不由JS控制的底层事件
容器侧主动发送给h5的消息
比如socket的状态变化
比如其他交互中出现的容器侧异常
- 命名：handleContainerEvent,handleRemoteEvent
- 注册：具名注册，即`命名`中提到的方法
3. h5和容器互相通信的请求 - 类似有返回值的函数调用
h5调用native能力，需要容器侧的回调
- 命名：每个单独命名，handleNative
4. h5和容器互相通信且涉及网络传输的部分 - 类似有返回值的函数调用
- 因为服务端无法解析http请求，所以需要客户端和服务端分别维护基于socket的长连接
- 命名：handleRemote
- 注册：只作为转发，依赖解析请求体内的apiEnum来构造相应的请求对象
- apiEnum为number类型
工具函数
1. handleResult
用于handleNative和handleRemote的正常处理
2. handleError
用于handleNative和handleRemote的异常处理
3. handleNotify
用于handleContainerEvent和handleRemoteEvent的处理
4. sendResponse
用于构造json对象，发送给h5


具体到项目中,具体例子有
1. h5到容器的消息 - 类似无返回值的函数调用
  比如将console的log,error,warn,info方法和容器侧的jsoncpp库绑定，将日志传递给容器侧，容器侧将日志写入文件
2. 容器到h5的消息 - 不由JS控制的底层事件
  假设容器侧捕获了一些不影响正常运行的错误，将错误信息传递给h5，h5侧将错误信息展示在页面上
3. h5和容器互相通信的请求 - 类似有返回值的函数调用
  针对本地文件的操作
- 文件列表的读取
- 文件元信息的读取
- 备份文件
- 还原文件
- 已备份文件的commit列表读取
- 文件列表筛选

4. h5和容器互相通信且涉及网络传输的部分 - 类似有返回值的函数调用
~~针对网盘文件的操作~~
- ~~文件列表的读取~~
- ~~文件元信息的读取~~
- ~~备份文件~~
- ~~还原文件~~
- ~~已备份文件的commit列表读取~~
- ~~文件列表筛选~~
针对一些特殊功能的操作
- 定时备份
- 自动备份


> 如果要同时支持本地和网盘，前端要在api侧进行封装，将本地和网盘的api统一起来，这样前端就不需要关心是本地还是网盘，只需要调用api即可


# 服务端

2类服务端

1. ~~网盘服务端~~

- ~~文件列表的读取~~
- ~~文件元信息的读取~~
- ~~备份文件~~
- ~~还原文件~~
- ~~已备份文件的commit列表读取~~
- ~~文件列表筛选~~
- ~~定时备份~~
- ~~自动备份~~

2. 本地服务端

- 定时备份
- 自动备份


服务端需要序列化/反序列化json的能力